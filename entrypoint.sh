#!/bin/ash
# shellcheck shell=dash
set -e

DEBUG=${DEBUG:-"false"}
DEBUG=$(echo "$DEBUG" | tr "[:upper:]" "[:lower:]")
ROOT_DOMAIN=${ROOT_DOMAIN:-"the.gate"}
ROOT_DOMAIN=$(echo "$ROOT_DOMAIN" | tr "[:upper:]" "[:lower:]")
NGINX_ACCESS_LOG=${NGINX_ACCESS_LOG:-"false"}
NGINX_ACCESS_LOG=$(echo "$NGINX_ACCESS_LOG" | tr "[:upper:]" "[:lower:]")
NGINX_ERROR_LOG=${NGINX_ERROR_LOG:-"false"}
NGINX_ERROR_LOG=$(echo "$NGINX_ERROR_LOG" | tr "[:upper:]" "[:lower:]")
NGINX_ERROR_LOG_LEVEL=${NGINX_ERROR_LOG_LEVEL:-"warn"}
NGINX_ERROR_LOG_LEVEL=$(echo "$NGINX_ERROR_LOG_LEVEL" | tr "[:upper:]" "[:lower:]")
REDIRECT_TYPE=${REDIRECT_TYPE:-"http"}
REDIRECT_TYPE=$(echo "$REDIRECT_TYPE" | tr "[:upper:]" "[:lower:]")
TLS=${TLS:-"self"}
TLS=$(echo "$TLS" | tr "[:upper:]" "[:lower:]")
CF_IP_CORRECTION=${CF_IP_CORRECTION:-"false"}
CF_IP_CORRECTION=$(echo "$CF_IP_CORRECTION" | tr "[:upper:]" "[:lower:]")
CF_STRICT=${CF_STRICT:-"false"}
CF_STRICT=$(echo "$CF_STRICT" | tr "[:upper:]" "[:lower:]")
OCSP_STAPLING=${OCSP_STAPLING:-"false"}
OCSP_STAPLING=$(echo "$OCSP_STAPLING" | tr "[:upper:]" "[:lower:]")

if [ "$DEBUG" != "true" ] && [ "$DEBUG" != "false" ]; then
  echo "[!] Invalid option for DEBUG, expected \"true\" or \"false\""
  exit 1
fi

if ! echo "$ROOT_DOMAIN" | grep -E "^[a-z0-9-]+(\.[a-z0-9]+)+$" > /dev/null 2>&1; then
  echo "[!] Invalid option for ROOT_DOMAIN, invalid domain name used"
  exit 1
fi

if [ "$NGINX_ACCESS_LOG" != "true" ] && [ "$NGINX_ACCESS_LOG" != "false" ]; then
  echo "[!] Invalid option for NGINX_ACCESS_LOG, expected \"true\" or \"false\""
  exit 1
fi

if [ "$NGINX_ERROR_LOG" != "true" ] && [ "$NGINX_ERROR_LOG" != "false" ]; then
  echo "[!] Invalid option for NGINX_ERROR_LOG, expected \"true\" or \"false\""
  exit 1
fi

if [ "$NGINX_ERROR_LOG_LEVEL" != "debug" ] && [ "$NGINX_ERROR_LOG_LEVEL" != "info" ] && [ "$NGINX_ERROR_LOG_LEVEL" != "notice" ] && [ "$NGINX_ERROR_LOG_LEVEL" != "warn" ] && [ "$NGINX_ERROR_LOG_LEVEL" != "error" ] && [ "$NGINX_ERROR_LOG_LEVEL" != "crit" ] && [ "$NGINX_ERROR_LOG_LEVEL" != "alert" ] && [ "$NGINX_ERROR_LOG_LEVEL" != "emerg" ]; then
  echo "[!] Invalid option for NGINX_ERROR_LOG_LEVEL, expected \"debug\", \"info\", \"notice\", \"warn\", \"error\", \"crit\", \"alert\", or \"emerg\""
  exit 1
fi

if [ "$REDIRECT_TYPE" != "http" ] && [ "$REDIRECT_TYPE" != "https" ]; then
  echo "[!] Invalid option for REDIRECT_TYPE, expected \"http\" or \"https\""
  exit 1
fi

if [ "$TLS" != "self" ] && [ "$TLS" != "letsencrypt" ] && [ "$TLS" != "mount" ]; then
  echo "[!] Invalid option for TLS, expected \"self\", \"letsencrypt\", \"mount\""
  exit 1
fi

if [ "$TLS" = "letsencrypt" ]; then
  if [ -z "$CERTBOT_EMAIL" ]; then
    echo "[!] CERTBOT_EMAIL not set for Let's Encrypt certificates"
    exit 1
  elif ! echo "$CERTBOT_EMAIL" | grep -E "^.+@.+\..+$" > /dev/null 2>&1; then
    echo "[!] Invalid option for CERTBOT_EMAIL, invalid eMail address used"
    exit 1
  fi
fi

if [ "$CF_IP_CORRECTION" != "true" ] && [ "$CF_IP_CORRECTION" != "false" ]; then
  echo "[!] Invalid option for CF_IP_CORRECTION, expected \"true\" or \"false\""
  exit 1
fi

if [ "$CF_STRICT" != "true" ] && [ "$CF_STRICT" != "false" ]; then
  echo "[!] Invalid option for CF_STRICT, expected \"true\" or \"false\""
  exit 1
fi

if [ "$OCSP_STAPLING" != "true" ] && [ "$OCSP_STAPLING" != "false" ]; then
  echo "[!] Invalid option for OCSP_STAPLING, expected \"true\" or \"false\""
  exit 1
fi

if [ "$DEBUG" = "true" ]; then
  echo "=== DEBUG ====================================================="
  echo "ROOT_DOMAIN: $ROOT_DOMAIN"
  echo "NGINX_ACCESS_LOG: $NGINX_ACCESS_LOG"
  echo "NGINX_ERROR_LOG: $NGINX_ERROR_LOG"
  echo "NGINX_ERROR_LOG_LEVEL: $NGINX_ERROR_LOG_LEVEL"
  echo "REDIRECT_TYPE: $REDIRECT_TYPE"
  echo "TLS: $TLS"
  if [ -n "$CERTBOT_EMAIL" ]; then
    echo "CERTBOT_EMAIL: $CERTBOT_EMAIL"
  fi
  echo "CF_IP_CORRECTION: $CF_IP_CORRECTION"
  echo "CF_STRICT: $CF_STRICT"
  echo "OCSP_STAPLING: $OCSP_STAPLING"
  echo "==============================================================="
fi

# Delete all files in sites-available and sites-enabled. In case this isn't fresh instance
rm -rf /etc/nginx/sites-available/* 2> /dev/null || true
rm -rf /etc/nginx/sites-enabled/* 2> /dev/null || true

# Copy (while overwriting files) from /etc/nginx/templates into /etc/nginx/
cp -rf /etc/nginx/templates/* /etc/nginx

echo "[-] Using \"$ROOT_DOMAIN\" to host"

# Setup Cloudflare IP correction
if [ "$CF_IP_CORRECTION" = "false" ]; then
  echo "[-] Skipping Cloudflare IP correction"
elif [ "$CF_IP_CORRECTION" = "true" ]; then
  echo "[-] Enabling Cloudflare IP correction"
  CF_IPV4=""
  for i in $(curl -s https://www.cloudflare.com/ips-v4); do
    CF_IPV4="$CF_IPV4  set_real_ip_from $i;\n"
  done
  sed -i "s,#{{CF_IPV4}},$CF_IPV4,g" /etc/nginx/nginx.conf

  CF_IPV6=""
  for i in $(curl -s https://www.cloudflare.com/ips-v6); do
    CF_IPV6="$CF_IPV6  set_real_ip_from $i;\n"
  done
  sed -i "s,#{{CF_IPV6}},$CF_IPV6,g" /etc/nginx/nginx.conf

  sed -i "s/#{{CF_IP}}/real_ip_header CF-Connecting-IP;/g" /etc/nginx/nginx.conf
fi

# Rename ROOT_DOMAIN
if [ -f /etc/nginx/sites-available/ROOT_DOMAIN ]; then
  mv /etc/nginx/sites-available/ROOT_DOMAIN "/etc/nginx/sites-available/$ROOT_DOMAIN"
fi

# Setup the logging options in nginx.conf
echo "[-] Configuring logging settings..."
if [ "$NGINX_ACCESS_LOG" = "true" ]; then
  sed -i "s/access_log off; #/access_log/g" "/etc/nginx/nginx.conf"
fi

if [ "$NGINX_ERROR_LOG" = "true" ]; then
  sed -i "s/error_log \/dev\/null; #/error_log/g" "/etc/nginx/nginx.conf"
fi

sed -i "s/{{NGINX_ERROR_LOG_LEVEL}}/$NGINX_ERROR_LOG_LEVEL/g" "/etc/nginx/nginx.conf"

# Replace variables in the files in the `/etc/nginx/sites-available/` directory
echo "[-] Replacing variables in vHost files..."
for file in /etc/nginx/sites-available/*; do
  if [ "$file" = "/etc/nginx/sites-available/hijacked-landing-pages" ]; then
    if [ "$REDIRECT_TYPE" = "http" ]; then
      echo "[-] Redirect is using HTTP"
      sed -i "s/https:\/\/{{ROOT_DOMAIN}}\//http:\/\/{{ROOT_DOMAIN}}\//g" "$file"
    else
      echo "[-] Redirect is using HTTPS"
    fi
  fi

  sed -i "s/{{ROOT_DOMAIN}}/$ROOT_DOMAIN/g" "$file"

  # Bind to IPv6 interface if it's available
  if [ -f "/proc/net/if_inet6" ]; then
    sed -i "s/#{{IPV6}} //g" "$file"
  fi

  if [ "$file" = "/etc/nginx/sites-available/$ROOT_DOMAIN" ]; then
    # Use Let's Encrypt TLS certificates
    if [ "$TLS" = "letsencrypt" ]; then
      echo "[-] Using Let's Encrypt for TLS certificates"

      echo "[-] Running certbot to get TLS certificates for $ROOT_DOMAIN"
      certbot certonly -n --agree-tos --no-eff-email --email "$CERTBOT_EMAIL" --webroot-path /var/www/themes/default -d "$ROOT_DOMAIN,*.$ROOT_DOMAIN" --post-hook "nginx -s reload"

      sed -i "s/#{{LETSENCRYPT}} //g" "$file"
    fi

    # Use self signed TLS certificates
    if [ "$TLS" = "self" ]; then
      echo "[-] Using self signed TLS certificates"
      sed -i "s/#{{SELF}} //g" "$file"
    fi

    # Use mounted TLS certificates
    if [ "$TLS" = "mount" ]; then
      echo "[-] Expecting Docker mounts for TLS. Map your certificates to the following locations:"
      echo "/etc/nginx/certs/fullchain.pem"
      echo "/etc/nginx/certs/private/privkey.pem"
      echo "/etc/nginx/certs/chain.pem"

      sed -i "s/#{{MOUNT}} //g" "$file"
    fi

    # Strict TLS settings for Cloudflare
    if [ "$CF_STRICT" = "true" ]; then
      echo "[-] Enabling strict Cloudflare TLS"
      sed -i "s/#CF_STRICT //g" "$file"
      curl -L https://support.cloudflare.com/hc/en-us/article_attachments/360044928032/origin-pull-ca.pem -o /etc/nginx/certs/origin-pull-ca.pem
      chmod 644 /etc/nginx/certs/origin-pull-ca.pem
    elif [ "$CF_STRICT" = "false" ]; then
      echo "[-] Skipping strict Cloudflare TLS"
    fi

    # OCSP Stapling
    if [ "$OCSP_STAPLING" = "true" ]; then
      echo "[-] Enabling OCSP Stapling"
      sed -i "s/#OCSP_STAPLING //g" "$file"
    elif [ "$OCSP_STAPLING" = "false" ]; then
      echo "[-] Skipping OCSP Stapling"
    fi
  fi
done

# Generate snakeoil certs for domains found in hijacked domains (Up to 8 sections for the domain)
openssl req -nodes -x509 -newkey rsa:4096 -keyout /etc/nginx/certs/private/snakeoil.key -out /etc/nginx/certs/snakeoil.crt -days 36500 -subj '/CN=*/CN=*.*/CN=*.*.*/CN=*.*.*.*/CN=*.*.*.*.*/CN=*.*.*.*.*.*/CN=*.*.*.*.*.*.*/CN=*.*.*.*.*.*.*.*' > /dev/null 2>&1
chmod 644 /etc/nginx/certs/snakeoil.crt
chmod 640 /etc/nginx/certs/private/snakeoil.key

# Enable all vHosts in site-available
echo "[-} Enabling all vHosts in /etc/nginx/sites-available directory..."
for file in /etc/nginx/sites-available/*; do
  ln -sf "$file" "/etc/nginx/sites-enabled/"
done

# Enable all modules currently in modules
echo "[-} Enabling all modules in /etc/nginx/modules directory..."
for file in /etc/nginx/modules/*; do
  ln -sf "$file" "/etc/nginx/modules-enabled/"
done

# Make network test files if they don't exist, fails silently
mkdir -p /var/www/ps-net-tests || true
if [ ! -f /var/www/ps-net-tests/get_2m ] || [ ! -f /var/www/ps-net-tests/get_6m ]; then
  echo "[-] Generating binary files for network tests..."
  truncate -s 2M /var/www/ps-net-tests/get_2m || true
  truncate -s 6M /var/www/ps-net-tests/get_6m || true
fi

echo "[-] Starting NGINX..."
exec "$@"
